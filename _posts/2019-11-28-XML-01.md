---
layout: post
title: XML 使用一（为数据绑定解释的一种设计）
categories: XML
tags : XML
author: 彭浩
---

## 基础知识
（1）定义：不是显示数据，而是存储数据，并可以自定义标签  
（2）应用：不同系统之间传输数据，表示生活中有关系的数据，用在配置文件中  
（3）语法：

    1）XML的文档声明
      * 创建一个文件，后缀名为.xml
      * 文档声明 <?xml version="1.0" coding="utf-8"?>，放在第一行第一列，其包含几个属性，"version"，"coding"，"standalone"（是否需要依赖其他的文件值为yes或no）
      * xml中文乱码问题，xml默认保存在硬盘上的编码为gbk，而文档属性中coding设置的是执行xml时使用的编码utf-8，则会出现编码问题，此时需要换为一致
    
    2）xml元素的定义
      * 一个xml中，只能有一个根标签，其他标签都是该标签的子标签或者孙标签
      * 在xml中，把空格和换行都当做内容来解析
      * xml中的命名规则，xml区分大小写，不能以数字或者“_”开头，不能以xml（Xml、XML等关键词）开头作为前缀，不能包含空格，不能包含冒号

    3）xml中属性的定义
      * 一个标签上可以有多个属性，属性值可以用单引号或者双引号，属性名称不允许重复，属性名称同样遵循元素定义的规范
    
    4）xml中的注释
      * 注释实例<!-- --> 
      * 注释不能嵌套
    
    5）xml的特殊字符
      * 转义字符：&--->&amp; < --->&lt; > --->&gt; " --->&quot; ' --->&apos;

    6）xml的CDATA区
      * 可以解决多个字符都需要转义的操作，可以将内容放到CDATA区里面，就不需要进行转义了
      * 写法，<![CDATA[ 内容 ]]>

    7）PI指令（处理指令）
      * 可以在xml设置样式
      * 写法：<?xml-stylesheet type="text/css" href="xxx.css"?>
      * 对中文不起作用，一般不用

    8）xml的约束
      * dtd和schema的约束

## DTD（文档类型定义）约束
  （1）步骤：

      * 创建一个后缀名为.dtd的文件作为xml的约束文件
      * 查看xml中有多少个元素，在dtd文件中就写几个 <!ELEMENT>
      * 判断元素是简单元素还是复杂元素（有嵌套元素），针对复杂元素的写法：<!ELEMENT 元素名称 (子元素)>，针对简单元素写法：<!ELEMENT 元素名称 (#PCDATA)>
      * 需要在xml中引入dtd文件，写法：<!DOCTYPE 根元素的名称 SYSTEM "dtd文件路径">

  （2）xml引入dtd文件的三种方式

    * 引入外部的dtd文件，<!DOCTYPE 根元素名称 SYSTEM "dtd路径">
    * 引入内部的dtd文件，
    <!DOCTYPE 根元素名称 [
        <!ELEMENT person (name,age)>
        <!ELEMENT name (#PCDATA)>
        <!ELEMENT age (#PCDATA)>
        ]>
    * 使用外部的dtd文件（网络上的dtd文件），<!DOCTYPE 根元素名称 PUBLIC "dtd名称" "dtd文档的URL">
  
  （3）使用dtd定义xml元素

    * 语法：<!ELEMENT 元素名 约束>
    * 简单元素的约束：<!ELEMENT 元素名 (#PCDATA)>，其中#PCDATA)约束表示值字符串，还可以替换为EMPTY约束表示没有内容，ANY约束表示任意
    * 复杂元素的约束：<!ELEMENT 元素名 (子元素)>，子元素只能出现一次，使用“+”号、“?”号和“*”号表示子元素能够出现的次数，“+”号表示一次或者多次，“?”号表示零次或者一次，而“*”号表示任意次。而子元素之间的“,”号表示元素之间的顺序。如果之间采用“|”号，则表示只能出现其中任意一个元素

  （4）使用dtd定义xml属性

    * 语法：<!ATTLIST 元素名 属性名称 属性类型 属性的约束>其中属性名称可以有多个
    * 属性类型：CDATA类型表示字符串，枚举类型表示在一定范围内出现的值，但是每次仅出现一次，其写法 (aa|bb|cc)，ID类型表示只能字母或者下划线开头
    * 属性的约束，#REQUIRED约束表示一定要出现，#IMPLIED约束表示属性可有可无，#FIXED “AAA” 约束表示一个固定值，值为AAA。直接值约束直接在属性类型后面跟上一个值表示默认值，当有该显式的设置了属性值，则会是显式的值。

  （5）使用dtd定义实体

    * 语法：<!ENTITY 实体名称 "实体的值">，使用 &实体名称;
    * 注意：定义的实体在内部的dtd定义里，外部则在某些浏览器中不可用
* 实例  
 --1.xml文件
 ```xml
<?xml version="1.0" encoding="UTF-8"?>
<!--<!DOCTYPE person SYSTEM "1.dtd">-->
<!DOCTYPE person [
        <!ELEMENT person (name+,age?,sex*,school,birthday)>
        <!ELEMENT name (#PCDATA)>
        <!ATTLIST name ID3 ID #REQUIRED>
        <!ELEMENT age (#PCDATA)>
        <!ATTLIST age ID2 (AA|BB|CC) #REQUIRED>
        <!ELEMENT sex (#PCDATA)>
        <!ATTLIST sex ID4 CDATA #FIXED "ABC">
        <!ELEMENT school (#PCDATA)>
        <!ATTLIST school ID5 CDATA "WW">
        <!ELEMENT birthday (#PCDATA)>
        <!ATTLIST birthday ID1 CDATA #IMPLIED>
        <!ENTITY TEST "HHHH">
        ]>
<person>
    <name ID3="A1">&TEST;</name>
    <age ID2="AA">20</age>
    <sex ID4="ABC"></sex>
    <school ID5="555">xx</school>
    <birthday>2015</birthday>
</person>
 ```


## xml的解析

（1）解析方式（技术）：dom和sax  
（2）优缺点：dom根据xml的层级结构在内存中分配一个树型结构，将xml的标签、属性和文本都封装成对象，缺点是文件过大时会造成内存溢出，优点是方便实现增删改操作。而sax采用事件驱动，边读边解析，从上至下一行行解析将对象名称返回，优点是不会造成内存溢出，方便的实现查询，缺点是不能实现增删改操作。  
（3）提供dom与sax解析方式的解析器的公司，通过api提供

    * sun公司的jaxp
    * dom4j组织的dom4j（实际开发中）
    * jdom组织的jdom

（4）jaxp的api（查看jdk文档即可）

    * 包javax.xml.parsers下，针对dom的DocumentBuilder、DocumentBuilderFactory，针对sax的SAXParser、SAXParserFactory
    * DocumentBuilder是一个抽象类，其实例可以通过DocumentBuilderFactory.newDocumentBuilder()方法获取。其存在方法parse("xml路径")返回的是Document对象，返回的Document是一个接口，父节点是Node，如果document里面找不到想要的方法，到Node里找。
    * DocumentBuilderFactory也是一个抽象类，其实例可通过其方法newInstance()方法获取

（5）jaxp的使用  
需要解析的xml  
```xml
<?xml version="1.0" encoding="UTF-8" ?>
<person>
    <p1>
        <name>zhangsan</name>
        <age>20</age>
    </p1>
    <p1>
        <name>lisi</name>
        <age>30</age>
    </p1>
</person>
```
* 使用dom的方式解析来查询节点
```java
// 公共操作
private static void saveXML(Document document) throws TransformerException {
        // 回写xml
        TransformerFactory transformerFactory = TransformerFactory.newInstance();
        Transformer transformer = transformerFactory.newTransformer();
        transformer.transform(new DOMSource(document), new StreamResult("src/person.xml"));
    }
private static Document getDocumentByName(String path) throws ParserConfigurationException, IOException, SAXException {
        // 创建解析器工厂
        DocumentBuilderFactory builderFactory = DocumentBuilderFactory.newInstance();
        // 创建解析器
        DocumentBuilder builder = builderFactory.newDocumentBuilder();
        // 解析xml返回document
        Document document = builder.parse(path);
        return document;
    }
// 查询所有name节点的值
private static void nameCount() throws ParserConfigurationException, SAXException, IOException {
        Document document = getDocumentByName("src/person.xml");
        // 得到name元素
        NodeList list = document.getElementsByTagName("name");
        // 遍历
        for (int i = 0; i < list.getLength(); i++) {
            Node n1 = list.item(i);
            // 获取标签的内容
            String str = n1.getTextContent();
            System.out.println(str);
        }
    }
    // 查询xml中第一个name元素的值
    private static void nameFirstCount() throws ParserConfigurationException, IOException, SAXException {
        Document document = getDocumentByName("src/person.xml");
        NodeList list = document.getElementsByTagName("name");
        Node first = list.item(0);
        if (first != null) {
            System.out.println(first.getTextContent());
        }
    }
```
* 使用jaxp来实现增加节点的操作
```java
// 在第一个p1标签下增加一个sex标签
private static void addSex() throws IOException, SAXException, ParserConfigurationException, TransformerException {
        Document document = getDocumentByName("src/person.xml");
        // 获取第一个标签
        Node firstP1 = document.getElementsByTagName("p1").item(0);
        if (firstP1 == null) {
            throw new NoSuchElementException("NoSuchElementError");
        }
        // 创建sex标签
        Element sex = document.createElement("sex");
        // 创建文本
        Text sexText = document.createTextNode("nan");
        // 将文本添加到sex下面
        sex.appendChild(sexText);
        // 将sex添加到第一个p1下面
        firstP1.appendChild(sex);
        // 回写xml
        saveXML(document);
    }
```
* 使用jaxp来实现修改节点的操作
```java
// 修改第一个p1标签下面的sex的内容是nv
private static void updateSex() throws IOException, SAXException, ParserConfigurationException, TransformerException {
        Document document = getDocumentByName("src/person.xml");
        // 获得第一个sex标签
        Node sex = document.getElementsByTagName("sex").item(0);
        if (sex == null) {
            throw new NoSuchElementException("NoSuchElementError");
        }
        // 修改sex里面的值
        sex.setTextContent("nv");
        // 回写
        saveXML(document);
    }
```
* 使用jaxp来实现删除节点的操作
```java
// 删除第一个p1标签下的sex节点
private static void deleteSex() throws IOException, SAXException, ParserConfigurationException, TransformerException {
        Document document = getDocumentByName("src/person.xml");
        // 获得第一个sex标签
        Node sex = document.getElementsByTagName("sex").item(0);
        if (sex == null) {
            throw new NoSuchElementException("NoSuchElementError");
        }
        // 获取sex的父节点
        Node sexParent = sex.getParentNode();
        // 删除使用父节点删除
        sexParent.removeChild(sex);
        // 回写xml
        saveXML(document);
    }
```
* 使用jaxp来实现遍历节点的操作
```java
// 将xml中所有节点的名称打印出来
private static void iteratorAllNode() throws IOException, SAXException, ParserConfigurationException {
        Document document = getDocumentByName("src/person.xml");
        // 使用递归进行遍历
        listAll(document);
    }

    // 递归遍历
    private static void listAll(Node node) {
        // 判断是否为元素类型，因为xml解析时会将换行和空格进行解析
        if (node.getNodeType() == Node.ELEMENT_NODE) {
            System.out.println(node.getNodeName());
        }
        // 得到第一层子节点
        NodeList list = node.getChildNodes();
        // 遍历list
        for (int i = 0; i < list.getLength(); i++) {
            // 得到每一个节点
            Node cur = list.item(i);
            // 继续得到cur的子节点
            listAll(cur);
        }
    }
```

（6）Schema约束，与DTD一样是一种用于定义和描述XML文档结构与内容模式语言，其出现是为了克服DTD的缺陷。一个schema文件就是一个xml文件

    * 特点：schema符合xml的语法，一个xml可以有多个schema但只能有一个dtd多个schema使用名称空间来区分，dtd里面只支持(#PCDATA)字符串类型而schema支持更多的数据类型

（7）schema的快速入门

    * 创建一个schema文件，后缀名是.xsd
    * 在schema文件里面，写入三个属性
      - xmlns="http://www.w3.org/2001/XMLSchema"表示当前xml是一个约束文件
      - targetNamespace="http://www.itcast.cn/20191111"直接通过这个地址引入约束文件
      - elementFormDefault="qualified"
    * 查看xml中有多少个节点元素
    * 看简单元素和复杂元素，复杂元素写法 <complexType><sequence>子元素</sequence></complexType>，简单元素写在复杂元素sequence里面
    * 在被约束xml文件中引入约束xsd文件，写法是在主标签节点中加入如下属性:
      - xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"表示该文件是一个被约束文件，其中xsi是
      - xmlns="http://www.itcast.cn/20191111"表示约束文档的命名空间
      - xsi:schemaLocation="http://www.itcast.cn/20191111 1.xsd"中包含两部分内容，第一个为约束文件的命名空间，而第二个为该约束文档.xsd的路径
* 实例  
--1.xsd文件
```xml
<?xml version="1.0" encoding="UTF-8"?>
<schema xmlns="http://www.w3.org/2001/XMLSchema" targetNamespace="http://www.itcast.cn/20191111" elementFormDefault="qualified">
    <element name="person">
        <complexType>
            <sequence>
                <element name="name" type="string"></element>
                <element name="age" type="int"></element>
            </sequence>
        </complexType>
    </element>
</schema>
```
--1.xml文件
```xml
<?xml version="1.0" encoding="UTF-8" ?>
<person xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
        xmlns="http://www.itcast.cn/20191111"
        xsi:schemaLocation="http://www.itcast.cn/20191111 1.xsd">
    <name>zhangsan</name>
    <age>20</age>
</person>
```
