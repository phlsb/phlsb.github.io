---
layout: post
title: JDBC
categories: JDBC
tags : JDBC
author: 彭浩
---

# JDBC基本操作

1、JPA连接数据库
```java
@Test
	public void connectionMySQL() throws ClassNotFoundException, SQLException {
		Class.forName("com.mysql.jdbc.Driver");
		String url = "jdbc:mysql://localhost:3306/test";
		String username = "root";
		String password = "root";
		
		Connection con = DriverManager.getConnection(url, username, password);
		System.out.println(con);
	}
```
注意：**所有的java.sql.Driver实现类，都提供了static块，块内的代码就是将自己注册到DriverManager中，这样就只需要Class.forName方法而不需要与DriverManager有显式的关联。但在jdbc4.0之后，每个驱动的jar包中，在META-INF目录下提供了一个名为java.sql.Driver的文件，而文件的内容就是该接口的实现类名称**

2、jdbc完成增、删、改、查

* 增、删、改

      通过Connection对象创建Statement，该Statement是用于向数据库发送sql语句的，调用它的int executeUpdate(String sql)，它可以发送DML、DDL
```java
@Test
public void insertUpdateDelet() throws ClassNotFoundException, SQLException {
		Class.forName("com.mysql.jdbc.Driver");
		String url = "jdbc:mysql://localhost:3306/test";
		String username = "root";
		String password = "root";
		
		Connection con = DriverManager.getConnection(url, username, password);
		// 通过Connection得到Statement对象
		Statement stmt = con.createStatement();
		// 使用Statement发送sql语句
		// String sql = "INSERT INTO stu VALUES('0003', 'wangwu', '88', 'male')";
		// String sql = "UPDATE stu SET name='zhaoliu' WHERE number='0001'";
		String sql = "DELETE FROM stu";
		int lineNumber = stmt.executeUpdate(sql);
		System.out.println(lineNumber);
            // 4、关闭资源
		rs.close();
		stmt.close();
		// 必须关闭
		con.close();
	}
```
* 查
```java
@Test
public void insertUpdateDelet() throws ClassNotFoundException, SQLException {
		Class.forName("com.mysql.jdbc.Driver");
		String url = "jdbc:mysql://localhost:3306/test";
		String username = "root";
		String password = "root";
		
		Connection con = DriverManager.getConnection(url, username, password);
		// 1、通过Connection得到Statement对象
		Statement stmt = con.createStatement();
		// 2、调用Statement的ResultSet rs = executeQuery(String querySql)
		String sql = "select * from stu";
		ResultSet rs = stmt.executeQuery(sql);
		// 3、解析ResultSet
		while (rs.next()) {
			String number = rs.getString("number");
			String name = rs.getString("name");
			int age = rs.getInt("age");
			String gender = rs.getString("gender");
			System.out.println(number + " " + name + " " + age + " " + gender);
		}
            // 4、关闭资源
		rs.close();
		stmt.close();
		// 必须关闭
		con.close();
	}
```
* 规范化写法（因为数据库连接及其他相关资源非常宝贵，所以需要关闭，在异常情况下也需要关闭）
```java
@Test
	public void fun3() throws ClassNotFoundException, SQLException {
		Connection con = null;
		Statement stmt = null;
		ResultSet rs = null;
		try {
			String driverClassName = "com.mysql.jdbc.Driver";
			String url = "jdbc:mysql://localhost:3306/test";
			String username = "root";
			String password = "root";
			
			// 加载
			Class.forName(driverClassName);
			con = DriverManager.getConnection(url, username, password);
			stmt = con.createStatement();
			String sql = "select * from stu";
			rs = stmt.executeQuery(sql);
			while(rs.next()) {
				System.out.println(rs.getString("number") + " " + 
						rs.getString("name") + " " + rs.getInt("age") + " " + rs.getString("gender"));
			}
		} catch(Exception e) {
			throw new RuntimeException();
		} finally {
			if (rs != null) rs.close();
			if (stmt != null) stmt.close();
			if (con != null) con.close();
		}
	}
```

3、Statement 详解
* int executeUpdate(String sql)方法可执行create、alter、drop、insert、update、delete
* ResultSet executeQuery(String sql)方法可执行select
* boolean execute(String sql)能执行以上两个方法的sql，执行完成后需要使用getUpdateCount()来获取insert、update、delete语句所影响的行数，而通过getResultSet()来获取select语句查询的结果

4、ResultSet 详解
注意，**要灵活的操作光标，必须在创建Statement时，必须调用的是带参的con.createStatement(int, int)方法**
* void beforeFirst()，将光标挪到第一行的前面，也是光标默认的位置
* void afterLast()，将光标挪到最后一行的后面
* boolean first()，将光标挪到第一行
* boolean last()
* boolean isBeforeFirst()
* boolean isAfterLast()
* boolean isFirst()
* boolean isAfter()
* boolean previous()
* boolean next()
* boolean relative(int row)，当row为正数时表示向下移动row行，而为负数时则表示向上移动row行
* boolean absolute(int row)，将光标移动到指定的行上
* int getRow()，返回当前光标行

* 获取结果集元数据ResultSetMetaData getMetaData()，该方法用于操作列数据

      * int getColumnCount()，获取结果集列数
	  * String getColumnName(String colIndex)，获取指定列的列名
**看个使用例子，在不知道结果集的情况下遍历结果集**
```java
	int count = rs.getMetaData().getColumnCount();
			while (rs.next()) {
				for (int i = 1; i <= count; i++) {
					System.out.print(rs.getObject(i) + " ");
				}
				System.out.println();
			}
```
4、了解

* con.createStatement(int, int)  

参数一：

    * ResultSet.TYPE_FORWARD_ONLY：不滚动结果集
	* ResultSet.TYPE_SCROLL_INSENSITIVE：滚动结果集，但结果集数据不会跟随数据库变化
	* ResultSet.TYPE_SCROLL_SENSITIVE：数据库厂商未实现  

参数二：  

    * CONCUR_READ_ONLY：结果集是只读的，不能通过修改结果集而影响数据库
	* CONCUR_UPDATE：结果集可更新，反向影响数据库


5、PreparedStatement

* 特点：防止SQL攻击、提高代码的可读性、可维护性、提高效率

* 使用：
```java
String sql = "select * frome user where username = ? and password = ?";
PreparedStatement pstmt = con.prepareStatement(sql);
pstmt.setString(1, username);
pstmt.setString(2, password);
pstmt.executeQuery(); // 更新时调用pstmt.executeUpdate()
```

* 原理

    * 服务器的工作：  
	（1）校验SQL语句的语法  
	（2）编译
	（3）执行
	* PreparedStatement
	（1）前提：连接的数据库必须支持预处理，几乎都支持
	（2）每个pstmt都与一个sql模板绑定在一起，先把sql模板给数据库，数据库先进性校验，再进行编译，，执行时仅将参数传入
	（3）第二次执行时，就不用再次校验语法，也不用再次编译，直接执行

* MySQL开启预编译命令

    * 可直接在jdbc:mysql://localhost:3306/mydb?useServerPrepStmts=true&cachePreStmts=true

* 将JDBC的模板代码封装为Utils小工具

    （1）首先写一个配置文件dbconfig.properties，里面包含driverClassName、url、username、password属性及其相应的值

```java
public class JdbcUtils {
public static Connection getConnection() {
	// 加载配置文件
	InputStream in = JdbcUtils.class.getClassLoader().getResourceAsStream("dbconfig.properties"); // 加载src下的dbconfig.properties
	Properties props = new Properties();
	props.load(in);
	// 加载驱动类
	Class.forName(props.getProperty("driverClassName"));
	// 调用DriverManager.getConnection()
	return DriverManager.getConnection(props.getProperty("url"), (props.getProperty("username"), (props.getProperty("password"));
}
}
```
* 改进只加载一次的写法 v1.0
```java
public class JdbcUtils {
	private static Properties props = null;
	static {
		try {
			// 加载配置文件
			InputStream in = JdbcUtils.class.getClassLoader().getResourceAsStream("dbconfig.properties"); // 加载src下的dbconfig.properties
			Properties props = new Properties();
			props.load(in);
		} catch (IOException e) {
			throw new RuntimeException(e);
		}

		try {
			// 加载驱动类
			Class.forName(props.getProperty("driverClassName"));
		} catch (ClassNotFoundException e){
			throw new RuntimeException(e);
		}
	}
	public static Connection getConnection() {
		// 加载驱动类
	Class.forName(props.getProperty("driverClassName"));
	// 调用DriverManager.getConnection()
	return DriverManager.getConnection(props.getProperty("url"), (props.getProperty("username"), (props.getProperty("password"));
	}
}
```
* 面向接口编程中，UserService中使用UserDao接口，并使用DaoFactory来返回具体的UserDao实现类。而工厂类给出静态的getUserDao方法实现可以使用配置文件加载的方式，然后反射加载具体的UserDao实现类