---
layout: post
title: jsp入门
categories: Web
tags : Web
author: 彭浩
---

# jsp基础

## jsp作用

（1）Servlet：

* 缺点：不适合设置html响应体
* 优点：动态资源，可以编程

（2）html：

* 缺点：html是静态页面，不能包含动态信息
* 优点：不用为输出html标签而发愁

（3）Jsp

* 优点：在原有html基础上添加java脚本，构成jsp页面

## jsp和servlet分工

（1）jsp：

* 作为请求发起页面，例如显示表单、超链接
* 作为结果显示页面，例如显示数据

（2）servlet：

* 作为请求中处理数据

## jsp9大内置对象

（1）request

（2）out对象

（3）session

（4）application

（5）response

（6）pageContext

（7）config

（8）page

（9）exception

## jsp的3种java脚本

（1）<%...%>，java代码片段常用，用于定义0~N条Java语句

（2）<%=...%>，java表达式，用于输出（常用）一条表达式（或变量）的结果

（3）<%!...%>，声明，用来创建类的成员变量和成员方法（基本不用）

## jsp的原理

（1）jsp是一种特殊的Servlet，当jsp页面被第一次访问时，服务器会把jsp编译成java文件（实际上是一个Servlet类），随后编译成.class，然后创建该类对象，最后调用它的service方法，第二次调用时，直接调用service方法。

（2）在tomcat的work目录下可以找到jsp对应的.java源码

# cookie入门（实际上就是将web中的数据状态进行持久化处理）

## HTTP协议与cookie

（1）由服务器创建保存到客户端浏览器的一个键值对，服务器保存Cookie的响应头：Set-Cookie: aaa=AAA。用java操作就是response.addHeader("Set-Cookie", "aaa=AAA");

（2）当浏览器请求服务器时，会把该服务器保存的cookie随请求发送给服务器，浏览器归还cookie的请求头

（3）HTTP规定（保证不给浏览器太大压力，但浏览器会违反）：

* 1个Cookie最大4kb
* 1个服务器最多向一个浏览器保存20个Cookie
* 1个浏览器最多可以保存300个Cookie

## Cookie用图（Cookie不能跨浏览器）

（1）服务器使用Cookie来跟踪客户端的状态

（2）保存购物车（购物车中的商品不能用request保存，因为它是一个用户向服务器发送的多个请求信息）

（3）显示上交登陆名（一用户多请求）

## JavaWeb中使用Cookie

（1）原始方式：

* 使用response发送Set-Cookie响应头
* 使用request获取Cookie请求头

（2）便捷方式

* 使用response.addCookie()方法向浏览器保存Cookie
* 使用request.getCookies()方法获取浏览器归还的Cookie

## Cookie详解

（1）Cookie不只是只有name和value两个属性

（2）Cookie的maxAge：Cookie的最大可保存时长，以秒为单位，例如cookie.setMaxAge(60)表示这个cookie会被浏览器保存到硬盘60s

* maxAge > 0，浏览器会将cookie保存到客户机的硬盘上，有效时长由maxAge指定
* maxAge < 0，cookie只在浏览器内存中存在，当用户关闭浏览器时，浏览器进程结束，cookie也就没有了
* maxAge = 0，浏览器会马上删除这个cookie

（3）Cookie的path：cookie的path并不是设置这个cookie在客户端保存的路径，该值由服务器创建创建cookie时设置，当浏览器访问服务器，当浏览器访问服务器某个路径时，需要归还哪些Cookie给服务器呢，这由cookie的path决定，浏览器访问服务器路径，如果包含某个cookie的路径，那么就归还这个cookie。如

* aCookie.path=/ph/; bCookie.path=/ph/jsps/; cCookie.path=/ph/jsps/cookies/;
* 访问：/ph/index.jsp时，归还：aCookie
* 访问：/ph/jsps/a.jsp时，归还aCookie，bCookie
* cookie的默认值：当前访问路径的父路径，如访问/ph/jsps/a.jsp时，响应的cookie，那么这个cookie的默认path为/ph/jsps/，即当客户端再次访问服务器的/ph/jsps下的所有路径时，都会带上这个cookie

（4）cookie的domain，domain用来指定cookie的域名，当多个二级域中共享cookie时才有用，例如www.baidu.com、zhidao.baidu.com、news.baidu.com、tieba.baidu.com之间共享cookie时才可以使用domain

* 设置domain为：cookie.setDomain(".baidu.com");
* 设置path为：cookie.setPath("/");


# HttpSession入门

## HttpSession概述

（1）HttpSession是由JavaWeb提供的，用来会话跟踪的类，session是服务端对象，保存在服务端！！！（Http只支持了cookie而不支持session，所以要放在服务端吗？这是原因之一吗？）

（2）HttpSession是servlet三大域对象之一，所以它也有setAttribute()、getAttribute()、removeAttribute()方法

（3）HttpSession底层依赖cookie、或是URL重写

## HttpSession的作用

（1）会话范围：从某个用户从首次访问服务器开始，到该用户关闭浏览器结束

（2）服务器会为每个客户端创建一个session对象，session就好比客户在服务器端的账户，它们被服务器保存到一个Map中，这个Map被称之为session缓存

* Servlet中得到session对象：HttpSession session = request.getSession();
* Jsp中得到session对象：session是jsp内置对象之下，不用创建就可以直接使用！

（3）session域相关方法：

* void setAttribute(String name, Object value)
* Object getAttribute(String name)
* void removeAttribute(String name)

## HttpSession原理（只要有getSession方法，就会向浏览器发送带有sessionId的cookie，JSP对象中会默认调用该方法，因为session其是内置对象）

（1）request.getSession()方法：

* 获取Cookie中的JSESSIONID：

      * 若sessionId不存在，创建session，把session保存起来，把新创建的sessionId保存到Cookie中
      * 若sessionId存在，通过session查找session对象，如果没有查找到，创建session，把session保存起来，将新创建的sessionId保存到cookie中
      * 如果sessionId存在，通过sessionId查找到了session对象，就不会再创建session对象了
      * 返回session
* 如果创建了新的session，浏览器会得到一个包含了sessionId的Cookie，这个cookie的生命周期为-1，即只在浏览器内存中存在，若不关闭浏览器，那么cookie不会销毁
* 下次请求时，再次执行request.getSession()方法时，因为可以通过cookie中的sessionId找到session对象，所以与上一次请求的是同一session对象。**注意cookie要存东西就要使用set-cookie头，而且传输是有限的**
* request.getSession(false)、request.getSession(true)、request.getSession()后两个方法效果相同

      * 第一个方法：若session缓存中不存在sessionId对应的session对象那么返回null，而不会创建session对象
      * 第二个方法：如前所述，会创建session对象

## HttpSession的其他方法

（1）String getId()：获取sessionId

（2）int getMaxInactiveInterval()：获取session可以的最大不活动时间（s），默认是30分钟，30分钟不活动，tomcat会从缓冲池中移除该session

（3）void invalidte()：让session失效，当客户端再次请求，服务器会给客户端创建一个新的session

（4）boolean isNew()：查看session是否为新，当客户端第一次请求时，服务器为客户端创建session，但这时服务器还没有响应客户端，也就是还没有把sessionId

## web.xml中配置session的最大不活动时间

```xml
<session-config>
      <session-timeout>30</session-timeout>
</session-config>
```

## url重写

就是原来使用cookie的方式给服务器sessionId的方式变为在请求参数中带上服务器产生的sessionId，有一个函数是在不支持cookie的时候自动加上请求参数sessionId，即response.encodeURL("..");


# JSP指令

## page指令

（1）写法：<%@page language="java" info="xxx" ...%>

（2）属性：

* pageEncoding和contentType：前者指定页面编码，后者表示添加一个Content-Type响应头。两者只要一个设置另一个就可以设置该值为默认。
* import：导包，可以写多个，用逗号隔开
* errorPage和isErrorPage：前者表示当前页面如果抛出异常，那么要转发到errorPage指定的位置。而后者表示当前页面是否是处理错误的页面，当该值设置为true时，这个页面会设置状态码为500，而且这个页面可以使用9大内置对象中的exception
* autoFlush和buffer，前者指定jsp的输出缓冲区满时，是否自动刷新！默认为true，若为false，那么缓冲区满时抛出异常。后者指定缓冲区大小，默认为8kb，通常不需要修改
* isELIgnored：是否忽略el表达式，默认值为false，不忽略，即支持
* language，默认值为java
* info
* isThreadSafe：默认值为false，表示不支持并发
* session：当前页面是否支持session，false表示不支持
* extends：让当前jsp继承该值指定的类

（3）web.xml中配置错误页面

* 不只是在jsp的page指令来配置错误页面，也可以通过web.xml文件来指定错误页面
```xml
<error-page>
      <error-code>404</error-code>
      <location>/error404.jsp</location>
</error-page>
<error-page>
      <exception-type>java.lang.RuntimeException</exception-type>
      <location>/error.jsp</location>
</error-page>
```

## jsp的九大内置对象

（1）out，jsp的输出流，用来客户端响应

（2）config，ServletConfig对象

（3）page，当前jsp对象真身，引用类型是Object，Object page = this;

（4）pageContext，一个顶九个

* Servlet有三大域，而JSP中有四大域，这是最后一个域对象

      ServletContext：整个应用程序
      session：整个会话（一个会话中只有一个用户）
      request：一个请求链
      pageContext：一个jsp页面，这个域是在当前jsp页面中使用的标签之间共享数据，可以代理其他域
* 代理其他域

      pageContext.setAttribute("xxx", "XXX", PageContext.SESSION_SCOPE);
* 获取其他域对象
* 全域查找：pageContext.findAttribute("xxx");从小到大，依赖查找。即小域优先，即page、request、session、application

（5）exception，Throwable

（6）request，HTTPServletRequest

（7）response，HTTPServletResponse

（8）application，ServletContext

（9）session，HttpSession


## include指令（静态包含）

（1）与RequestDispatcher的include()方法功能相似

（2）<%@include%>它是在编译成java文件时完成的，它们共同生成一个java（servlet）文件，然后生成一个class。而RequestDispather的include()是一个方法，包含和被包含的是两个servlet，即两个.class，它们只是将响应的内容在运行是合并在一起。

（3）作用：将页面分解了，使用包含的方式组合在一起，这样页面中不变的部分，就是独立的jsp，而我们只需要处理变化的页面

## taglib指令（导入标签库）

（1）属性

* prefix：指定标签库在本页面中的前缀，由我们自己来起名称
* uri：指定标签库的位置
* <%@taglib prefix="pre" uri="/struts-tags"%>，使用该标签库中的标签时则<pre:text>这样子